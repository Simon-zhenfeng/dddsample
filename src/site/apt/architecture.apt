  ------------
  Layering
  ------------

  The sample application is layered as illustrated by this picture:

[images/layers.png]

  There are three vertical layers: interfaces, application and domain, each supported by different kinds of infrastructure.

  * Interfaces

	This layer holds everythng that interacts with other systems, such as web services, RMI interfaces
	or web applications. It handles interpretation, validation and translation of incoming data. It also
	handles serialization of outgoing data, such as HTML or XML across HTTP to web browsers or web service
	clients, or DTO classes and distributed facade interfaces for remote Java clients.

  * Application

    The application layer is responsible for defining the use cases of the application, operations that can
    are interface-independent and can be synchronous or message-driven. This layer is well suited for spanning
    transactions, high-level logging and security.

    The application layer is thin in terms of domain logic - it merely coordinates the domain layer objects
    perform the actual work.

  * Domain

	The domain layer is the heart of the software, and this is where the interesting stuff happens.

    Everything below the domain package: domain service interfaces (and in some cases their implementations),
    repository interfaces (but not the implementations!) and the domain model with each aggregate in its own
    subpackage.


	Infrastructure

	In adition to the three vertical layers, there's also the infrastructure. As the the picture shows, it supports
	all of the three layers in different ways, facilitating communication between the layers.

    Hibernate mapping metadata files, Spring context definition files, logging configuration.
    All external libraries,  